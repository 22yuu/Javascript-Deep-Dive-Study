# 12장 함수

## 12.1 함수란?

함수는 일련의 과정을 문(statement)으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다.  
함수 내부로 입력을 전달받는 변수를 `매개변수`, 입력을 `인수`, 출력을 `반환값`이라 한다.  
함수는 `함수 정의`를 통해 생성한다. 자바스크립트의 함수는 다양한 방법으로 정의할 수 있다.

<br/>

## 12.2 함수를 사용하는 이유

함수는 필요할 때 여러 번 호출할 수 있다.  
**실행 시점을 개발자가 결정할 수 있고 재사용이 가능하다.** 따라서 함수를 사용함에 있어 코드의 중복을 억제하고 재사용을 높여주어 **유지보수의 편의성**을 높이고 실수를 줄여 코드의 신뢰성을 높이는 효과가 있다.

<br/>

## 12.3 함수 리터럴

자바스크립트의 함수틑 객체 타입이다. 숫자 값을 숫자 리터럴로 생성하고 객체를 객체 리터럴로 생성하는 것처럼 함수도 함수 리터럴로 생성할 수 있다.  
함수는 리터럴로 평가되어 값을 생성하고 함수는 **객체**로 값이 생성된다.  
함수가 객체라는 사실은 다른 프로그래밍 언어와 구별되는 중요한 특징이다.

<br/>

## 12.4 함수 정의

함수를 정의하는 방법에는 4가지가 있다.
함수 정의 방식 | 예시
------- | -------
함수 선언문 | function add(x,y){ return x + y;}
함수 표현식 | var add = function(x,y){ return x + y;}
Function 생성자 함수 | var add = new Function('x', 'y' , 'return x + y');
화살표 함수(ES6) | var add = (x,y) => x+y;

### 12.4.1 함수 선언문

함수 선언문은 함수 리터럴과 형태가 동일하다. 단, 함수 선언문은 표현식이 아닌 문이기 때문에 함수 선언문은 함수 이름을 생략할 수 없다.  
함수 선언문과 함수 리터럴 표현식은 함수가 생성되는 것은 동일하다. 하지만 함수를 생성하는 내부 동작에 차이가 있다.  
그것은 바로 호출할 때 차이가 발생하는데 함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다. 함수 선언문에서 함수 식별자를 선언한 적도 없고 할당한 적이 없어도 자바스크립트 엔진이 암묵적으로 생성해주어 호출할 수가 있다.

<br/>

### 12.4.2 함수 표현식

자바스크립트의 함수는 값처럼 변수에 할당할 수도 있고 프로퍼티 값이 될 수도 있으며 배열의 요소가 될 수도 있다. 이처럼 값의 성질을 갖는 객체를 **일급객체**라 한다. **자바스크립트의 함수는 일급객체이다.** 함수가 일급 객체라는 것은 함수를 값처럼 자유롭게 사용할 수 있다는 말이다.  
함수 리터럴의 함수 이름은 생략할 수 있다. 이러한 함수를 `익명 함수`라 한다.

<br/>

### 12.4.3 함수 생성 시점과 함수 호이스팅

함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있다. 그러나 함수 표현식은 그렇게 할 수 없다.  
이것은 **함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르기 때문이다.**  
함수 선언문은 코드의 선두로 끌어 올려진 것처럼 동작하는 **함수 호이스팅** 때문이다. 런타임 이전에 var 키워드로 선언된 변수는 `undefined`로 초기화 되고 함수 선언문 또한 마찬가지이다.

 <br/>

### 12.4.4 Function 생성자 함수

자바스크립트가 기본 제공하는 빌트인 함수인 Function 생성자 함수에 매개변수 목록과 함수 몸체를 문자열로 전달하면서 `new`연산자와 함께 호출하면 함수 객체를 생성하여 반환한다. (`new` 연산자 없이 호출해도 결과는 동일)  
 하지만 Function 생성자 함수로 함수를 생성하는 방식은 바람직하지 않다.  
 이것은 클로저를 생성하지 않고, 함수 선언문이나 함수 표현식으로 생성한 함수와 다르게 동작한다.

 <br/>

### 12.4.5 화살표 함수

ES6에서 도입된 화살표 함수는 이전에 방법에 비해 매우 간단하게 함수를 정의할 수 있다.  
 그러나 주의해야 할 점은 화살표 함수는 생성자 함수로 사용할 수 없고, 기존 함수와 `this` 바인딩 방식이 다르고, `prototype` 프로퍼티가 없고 `arguments`객체를 생성하지 않는다.

 <br/>

## 12.6 참조에 의한 전달과 외부 상태의 변경

매개변수도 함수 몸체 내부에서 변수와 동일하게 취급되므로 매개변수 또한 `값에 의한 전달`, `참조에 의한 전달` 방식을 그대로 따른다.

```
function changeVal(privitive, obj){
   primitive += 100;
   obj.name = 'Kim';
}
var num = 100;
var person = {name : 'Lee'};

changeVal(num,person);

//원시값은 훼손되지 않는다.
console.log(num); // 100

//객체는 원본이 훼손된다.
console.log(person); // {name : 'Kim'}
```

원시 값을 넘겨준 매개변수는 값이 변하지 않고 객체는 변경 가능한 값이므로 원본이 변경된다.
이렇게 객체의 원본을 훼손하지 않으려면 `깊은 복사`를 통해 새로운 객체를 생성하고 재할당을 통해 교체한다. 이를 통해 외부 상태가 변경되는 부수 효과를 없앨 수 있다.

<br/>

## 12.7 다양한 함수의 형태

### 12.7.1 즉시 실행 함수

함수 정의와 동시에 즉시 호출되는 함수를 `즉시 실행 함수`라고 한다. 이것은 단 한 번만 호출되며 다시 호출할 수 없다.

```
(function ()
    var a = 3;
    var b = 5;
    return a * b;
)());
```

즉시 실행 함수는 익명함수를 사용하는 것이 일반적이다. 기명 함수도 사용할 수는 있다. 하지만 그룹 연산자(...) 내의 기명 함수는 함수 선언문이 아니라 함수 리터럴로 평가되어 함수 이름은 함수 몸체에서만 참조 가능하여 외부에서 호출할 수 없다.  
즉시 실행 함수는 그룹 연산자(...)로 감싸야 한다. 그렇지 않으면 에러가 발생한다.

<br/>

### 12.7.2 재귀 함수

함수가 자기 자신을 호출하는 것을 `재귀 호출`이라 한다.  
재귀 함수는 반복되는 처리를 위해 사용한다.
대표적인 예가 팩토리얼을 재귀 함수로 간단하게 구현할 수 있다.

```
function factorial(n){
    if(n <= 1) return 1;
    return n * factorial(n-1);
}
console.log(factorial(5)); // 5*4*3*2*1 = 120
```

<br/>

### 12.7.3 중첩 함수

함수 내부에 정의된 함수를 중첩 함수 또는 내부 함수라고 한다. 그리고 중첩 함수를 포함하는 함수는 외부 함수라 부른다. 중첩 함수는 외부 함수 내에서만 호출할 수 있다.

```
function outer(){
    var x = 1;
    //중첩함수
    function inner(){
        var y = 2;
        console.log(x+y);
    }
    inner();
}
outer();
```

ES6부터 함수 정의는 문이 위치할 수 있는 문맥이라면 어디든지 가능하다. if문이나 for문 블록 내에도 정의는 가능하나, 권장하지는 않는다.

<br/>

### 12.7.4 콜백 함수

```
function repeat(n, f){
    for(var i=0; i<n; i++){
        f(i);
    }
}
var logOdds = function (i){
    if(i % 2) console.log(i)
};
repeat(5,logOdds);
```

함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백 함수라고 하며, 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 고차 함수라고 한다. 고차 함수는 콜백 함수를 자신의 일부분으로 합성한다.

<br/>
고차 함수는 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정해서 호출한다. 즉, 콜백 함수는 고차함수에 의해 호출되며 이때 고참함수는 필요에 따라 콜백함수에 인수를 전달할 수 있다.   
따라서 고차 함수에 콜백함수를 전달할 때 콜백함수를 호출하지 않고 함수 자체를 전달해야 한다.

<br/>

```
//콜백 함수를 사용한 이벤트 처리
//myButton 버튼을 클릭하면 콜백 함수를 실행한다.
document.getElementById('myButton').addEventListener('click', function(){
    console.log('button clicked!');
})
//콜백 함수를 사용한 비동기 처리
//1초 후에 메시지를 출력한다.
setTimeout(function(){
    console.log('1초 경과');
},1000);
```

콜백 함수는 비동기 처리(이벤트 처리, Ajax 통신, 타이머 함수 등) 뿐 아니라 배열 고차 함수에서도 사용된다.

```
//콜백 함수를 사용하는 고차 함수 map
var res = [1,2,3].map(function(item){
    return item * 2;
})
//콜백 함수를 사용하는 고차 함수 filter
var res = [1,2,3].filter(function(item){
    return item % 2;
})
//콜백 함수를 사용하는 고차 함수 reduce
var res = [1,2,3].reduce(function(acc,cur){
    return acc + cur;
},0)
```

<br/>

### 12.7.5 순수 함수와 비순수 함수

함수형 프로그래밍에서 어떤 외부 상태에 의존하지 않고 변경하지도 않는, `부수 효과가 없는` 함수를 **순수 함수**라 하고, 외부 상태에 의존하거나 외부 상태를 변경하는, 즉 `부수 효과가 있는` 함수를 **비순수 함수**라 한다.  
비순수 함수를 많이 사용하면 코드의 복잡성을 증가시키고 예측하기 어려우며 오류 발생의 근복적인 원인이 될 수 있다.  
따라서 순수 함수와 보조 함수의 조합을 통해 외부 상태를 변경하는 부수 효과를 최소화해서 `불변성`을 지향하는 프로그래밍 패러다임(함수형 프로그래밍)을 하는 것이 좋다.
