# 4장 - 변수

안녕

### 목차

[1. 변수란 무엇인가? 왜 필요한가?](#1-변수란-무엇인가-왜-필요한가)
[2. 식별자](#2-식별자)
[3. 변수 선언](#3-변수-선언)
[4. 변수 선언의 실행 시점과 변수 호이스팅](#4-변수-선언의-실행-시점과-변수-호이스팅)
[5. 값의 할당](#5-값의-할당)
[6. 값의 재할당](#6-값의-재할당)
[7. 짚고 넘어가야할 부분](#7-짚고-넘어가야할-부분)
[8. Deep Dive](#8-deep-dive)
[8.1 메모리와 데이터](#81-메모리와-데이터)
[8.2 가비지 컬렉션(GC)](#82-가비지-컬렉션gc)

## 1. 변수란 무엇인가? 왜 필요한가?

- 하나의 값을 저장하기 위해 확보한 메모리 공간 자체
- 그 메모리 공간을 식별하기 위해 붙인 이름
- 값을 저장하고 참조하는 메커니즘으로 값의 위치를 가리키는 상징적인 이름
- 기억하고 싶은 값을 메모리에 저장하고 저장된 값을 읽어들여 재사용하기 위해 `변수`를 사용한다.

<b>용어</b>

- 변수명: 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름
- 변수값: 변수에 저장된 값
- 할당: 변수에 값을 저장하는 것
- 참조: 변수에 저장된 값을 읽어들이는 것

💥 코드는 개발자를 위한 문서! 변수에 저장된 값의 의미를 명확히 할수록 좋은 네이밍이다. → 네이밍은 Readable하게 작성!

## 2. 식별자

- 변수 이름을 `식별자`라고 함.
- 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말함
- 값이 아닌 메모리 주소를 기억하고 있음

## 3. 변수 선언

- 값을 저장하기 위한 메모리 공간을 확보 → 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비하는 것
- 변수 선언을 위해서 `let` `const` `var`와 같은 키워드를 사용
- 변수 선언에 의해 확보된 메모리 공간은 비어있지 않고 `undefined`라는 값이 암묵적으로 할당되어 초기화 된다. → 자바스크립트의 특징

## 4. 변수 선언의 실행 시점과 변수 호이스팅

- 변수 선언은 소스코드가 한 줄씩 순차적으로 실행되는 시점, 런타임이 아니라 그 이전 단계에서 먼저 실행됨
- 즉, 변수 선언이 소스 코드 어디에 있든 다른 코드보다 먼저 실행됨
- 소스코드의 어디에 위치하는지 상관없이 어디서든지 변수를 참조할 수 있음
- 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트의 고유의 특징을 `변수 호이스팅`이라 함.

💥 변수 뿐만 아니라 var, let, const , function, function\*, class키워드를 사용해서 선언하는 모든 식별자는 호이스팅 된다. → 모든 선언문은 런타임 이전 단계에 먼저 실행!

## 5. 값의 할당

- 소스코드가 순차적으로 실행되는 시점인 런타임에 실행

```javascript
console.log(score); // undefined

var score; // 1. 변수 선언
score = 80; // 2. 값의 할당

// var score = 80 // 변수 선언과 값의 할당

console.log(score); // 80
```

![image](https://user-images.githubusercontent.com/48381447/221576703-0e05174b-a936-4bf7-8cb5-eed6ae9276f4.png)

그림처럼 이전 값 `undefined`가 저장되어 있던 메모리 공간을 지우고 그 메모리 공간에 할당 값 80을 새롭게 저장하는 것이 아니라 새로운 메모리 공간을 확보하고 그곳에 할당 값을 80을 저장하므로 주의해야 한다.

## 6. 값의 재할당

- 이미 값이 할당되어 있는 변수에 새로운 값을 또다시 할당하는 것

```javascript
var score = 80;
score = 90;
```

![image](https://user-images.githubusercontent.com/48381447/221577390-e15e4dc2-4de4-4a94-bc33-c774a69d1b64.png)

재할당도 마찬가지로 변수에 값을 할당했을 때처럼 이전 값 80이 저장되어 있던 메모리 공간을 지우고 새로운 메모리 공간을 확보해 90을 저장한다. 80이 저장된 메모리 공간은 불필요하므로 `가비지 컬렉터`에 의해 메모리에서 자동 해제된다. → 만약 80이 다른 변수 등에 참조되어 있다면 `가비지 컬렉터`에 의해서 수거되지 않고 남아 있는다.

## 7. 짚고 넘어가야할 부분

- 변수를 사용하려면 반드시 선언이 필요
- ES6 vs ES5
- `var` 사용을 지양 → 여러 단점이 존재
  - 중복 선언
  - 함수레벨 스코프
  - 호이스팅
- 가비지 컬렉터

## 8. Deep Dive

### 8.1 메모리와 데이터

메모리는 데이터를 저장할 수 있는 메모리 셀의 집합체이다. 메모리 셀 하나의 크기는 1바이트(8비트)이며, 컴퓨터는 메모리 셀의 크기 즉 1바이트 단위로 데이터를 저장하거나 읽어들인다. 컴퓨터는 모든 데이터를 0 또는 1로 바꿔 기억하며 0 또는 1만 표현할 수 있는 하나의 메모리 조각을 비트라고 한다.

C/C++, 자바 등의 정적타입 언어에서는 메모리 낭비를 최소화하기 위해 데이터 타입별로 할당할 메모리 영역을 나누어 정해놓는다. 하지만 자바스크립트의 경우 메모리 용량이 과거보다 훨씬 커진 상황에서 등장해 메모리 공간을 넉넉하게 할당한다.

숫자의 경우 정수형인지 부동소수형인지를 구분하지않고 64비트 8바이트를 확보한다.

### 8.1.1 왜 자바스크립트는 변수를 저장할 때 메모리의 주소값을 저장할까?

`5. 값의 할당`에서의 메모리 영역 그림을 보면 `score`라는 변수가 선언 후 할당된다. `score`변수는 메모리에 있는 `80`이라는 값이 저장되어 있는 것이 안닌 `80`이 저장되어 있는 `0x00001332`의 메모리 주소를 가지고 있다. 왜 변수에 값을 저장하지 않고 굳이 한 단계를 더 거쳐서 메모리 주소를 저장하는 것일까?
→ 데이터 변환을 자유롭게 할 수 있게함과 동시에 메모리르 더욱 효율적으로 관리하기 위한 고민의 결과라고 한다. 앞서 자바스크립트는 숫자형 데이터에 대해 64비트(8바이트)의 공간을 확보한다고 했다. 반면 문자열은 특별히 정해진 규격이 없다. 한 글자마다 영어는 1바이트, 한글은 2바이트 등으로 각각 필요한 메모리 용량이 가변적이며 전체 글자 수 역시 가변적이기 때문이다.

미리 확보한 공간에서 데이터 변환을 할 수 있다면 데이터를 다시 저장하기 위해서 "확보된 공간을 변환된 데이터 크기에 맞게 늘리는 작업"이 선행되어야 할 것이다. 해당 공간이 메모리 상의 가장 마지막에 있었다면 뒤쪽으로 늘리기만 하면 된다. 하지만 중간에는 있는 데이터라면? 해당 공간보다 뒤에 저장된 데이터들을 전부 뒤로 옮기고, 이동시킨 주소를 각 식별자에 다시 연결해야 하는 작업을 해야 한다. 컴퓨터가 처리해야 할 연산이 많아 지는 것이다. 따라서 가변적인 데이터를 처리하기 위해 변수와 데이터를 별도의 공간에 나누어 저장하는 것이다.

또한 이렇게 데이터 영역과 변수 영역을 분리해 저장하면 중복된 데이터를 효율적으로 처리할 수 있다. 예를 들어 500개의 변수를 생성해서 모든 변수에 숫자 5를 할당하는 상황을 생각해보자, 이 경우 500개의 변수 공간을 확보해야 한다. 자브스크립트에서 숫자형 데이터를 저장하기 위해 8바이트가 필요하므로 500 x 8 = `4000` 바이트를 사용해야 한다. 그 대신 `5`를 별도의 공간에 한 번만 저장하고 해당 주소만 참조한다면? 주소 공간의 크기를 2바이트라고 가정하면 500 x 2(주소공간) + 8 (데이터 공간) = 1008 바이트만 사용하면 된다.

### 8.2 가비지 컬렉션(GC)

자바스크립트에서의 가비지 컬렉터가 동작하는 것을 알아보기 전에 자바스크립트에서 메모리를 어떻게 관리하고 할당하는지 알아보자.

### 8.2.1 자바스크립트의 메모리 관리

C 언어같은 저수준 언어에서는 메모리 관리를 위해 malloc()과 free()를 사용한다. 반면, 자바스크립트는 객체가 생성되었을 때 자동으로 메모리를 할당하고 더 이상 필요하지 않을 때 자동으로 해체한다.(가비지 컬렉션). 이러한 자동 메모리 관리는 잠재적 혼란의 원인이기도 한데, 개발자가 메모리 관리에 대해 고민할 필요가 없다는 잘못된 인상을 줄 수 있기 때문이다.

### 8.2.2 메모리 생존주기

메모리 생존주기는 프로그래밍 언어와 관계없이 비슷하다.

1. 필요할 때 할당한다.
2. 할당된 메모리를 사용한다.(읽기, 쓰기)
3. 더 이상 필요하지 않으면 해체한다.

두 번째 부분은 모든 언어에서 명시적으로 사용된다. 그러나 첫 번째 부분과 마지막 부분은 저수준 언어에서는 명시적이며, 자바스크립트와 같은 대부분의 고수준 언어에서는 암묵적으로 작동한다.

### 8.2.3 자바스크립트에서 메모리 할당

- 값을 초기화할 때
- 함수 호출을 통해 할당할 때

```javascript
var d = new Date(); // Date 개체를 위해 메모리를 할당
var e = document.createElement('div'); // DOM 엘리먼트를 위해 메모리를 할당
```

- 메소드가 새로운 값이나 오브젝트를 할당할 때

```javascript
var s = 'azerty';
var s2 = s.substr(0, 3); // s2는 새로운 문자열
// 자바스크립트에서 문자열은 immutable 값이기 때문에,
// 메모리를 새로 할당하지 않고 단순히 [0, 3] 이라는 범위만 저장합니다.

var a = ['ouais ouais', 'nan nan'];
var a2 = ['generation', 'nan nan'];
var a3 = a.concat(a2);
// a 와 a2 를 이어붙여, 4개의 원소를 가진 새로운 배열
```

### 8.2.4 할당된 메모리가 더 이상 필요없을 때 해제하기

저수준 언어에서는 개발자가 직접 메모리를 할당하고, 해제할 수 있다. 이러한 방법은 프로그램을 최적의 성능으로 구현할 수 있는 좋은 방법이다. 하지만 잘못 사용하게 되면 큰 오류가 발생하거나 오히려 프로그램의 성능을 떨어질 수도 있다. 자바스크립트 같은 고수준 언어에서는 “가비지 콜렉션” 이라는 자동 메모리 관리 방법을 사용한다. 가비지 콜렉터의 목적은 메모리 할당을 추적하고 할당된 메모리 블록이 더 이상 필요하지 않게 되었는지를 판단하여 회수하는 것이다.

### 8.2.5 가비지 콜렉션 알고리즘

“더 이상 필요하지 않은” 모든 메모리르 찾는건 어렵다. 따라서 가비지 컬렉터들은 이 문제에 대한 제한적인 해결책을 구현한다.

### 참조

가비지 콜렉션 알고리즘의 핵심 개념은 “참조”이다. A라는 메모리르 통해 (명시적이든 암시적이든) B라는 메모리에 접근할 수 있다면 “B는 A에 참조된다”라고 한다. 예를 들어 모든 자바스크립트 오브젝트는 prototype을 암시적으로 참조하고 그 오브젝트의 속성을 명시적으로 참조한다. → 여기서 “오브젝트”의 범위는 일반 자바스크립트의 오브젝트와 함수 범위를 포함한 더 넓은 범위를 의미한다.

### 참조-세기(Reference-counting) 가비지 콜렉션

참조-세기 알고리즘은 가장 소박한 알고리즘이다. 이 알고리즘은 “더 이상 필요없는 오브젝트”를 “어떤 다른 오브젝트도 참조하지 않는 오브젝트”라고 정의한다. 이 오브젝트를 “가비지”라 부르며, 이를 참조하는 다른 오브젝트가 하나도 없는 경우 수집한다.

```javascript
// 예제
var x = {
  a: {
    b: 2,
  },
};
// 2개의 오브젝트가 생성되었습니다. 하나의 오브젝트는 다른 오브젝트의 속성으로 참조됩니다.
// 나머지 하나는 'x' 변수에 할당되었습니다.
// 명백하게 가비지 콜렉션 수행될 메모리는 하나도 없습니다.

var y = x; // 'y' 변수는 위의 오브젝트를 참조하는 두 번째 변수입니다.

x = 1; // 이제 'y' 변수가 위의 오브젝트를 참조하는 유일한 변수가 되었습니다.

var z = y.a; // 위의 오브젝트의 'a' 속성을 참조했습니다.
// 이제 'y.a'는 두 개의 참조를 가집니다.
// 'y'가 속성으로 참조하고 'z'라는 변수가 참조합니다.

y = 'mozilla'; // 이제 맨 처음 'y' 변수가 참조했던 오브젝트를 참조하는 오브젝트는 없습니다.
// (역자: 참조하는 유일한 변수였던 y에 다른 값을 대입했습니다)
// 이제 오브젝트에 가비지 콜렉션이 수행될 수 있을까요?
// 아닙니다. 오브젝트의 'a' 속성이 여전히 'z' 변수에 의해 참조되므로
// 메모리를 해제할 수 없습니다.

z = null; // 'z' 변수에 다른 값을 할당했습니다.
// 이제 맨 처음 'x' 변수가 참조했던 오브젝트를 참조하는
// 다른 변수는 없으므로 가비지 콜렉션이 수행됩니다.
```

한계: 순환 참조

함수 호출이 완료되면 이 두 객체는 스코프를 벗어난다. 그 시점에 두 객체는 불필요해지므로 할당된 메모리는 회수되어야 한다. 그러나 두 객체가 서로를 참조하고 있으므로 참조-세기 알고리즘은 둘 다 가비지 컬렉션의 대상으로 표시하지 않는다. 이러한 순환 참조는 메모리 누수의 흔한 원인이다.

```jsx
function f() {
  var x = {};
  var y = {};
  x.a = y; // x는 y를 참조합니다.
  y.a = x; // y는 x를 참조합니다.

  return 'azerty';
}

f();
```

### 표시하고-쓸기(Mark-and-sweep) 알고리즘

이 알고리즘은 “더 이상 필요없는 오브젝트”를 “닿을 수 없는 오브젝트”로 정의한다.

이 알고리즘은 `roots`라는 오브젝트의 집합을 가지고 있다.(자바스크립트에서는 전역 변수들을 의미) 주기적으로 가비지 컬렉터는 roots로 부터 시작하여 roots가 참조하는 오브젝트들, roots가 참조하는 오브젝트가 참조하는 오브젝트들…을 “닿을 수 있는 오브젝트”라고 표시한다. 그리고 닿을 수 있는 오브젝트가 아닌 닿을 수 없는 오브젝트에 대해 가비지 컬렉션을 수행한다.

이 알고리즘은 참조-세기 알고리즘보다 효율적이다. 왜냐하면 “참조되지 않는 오브젝트”는 모두 “닿을 수 없는 오브젝트”이지만 역은 성립하지 않기 때문이다.

2012년 기준으로 모든 최신 브라우저들은 가비지 컬렉션에서 표시하고-쓸기 알고리즘을 사용한다. 지난 몇 년간 연구된 자바스크립트 가비지 콜렉션 알고리즘의 개선들은 모두 이 알고리즘에 대한 것이다. 개선된 알고리즘도 여전히 “더 이상 필요없는 오브젝트”를 “닿을 수 없는 오브젝트”로 정의하고 있다.

한계: 수동 메모리 해제.

어떤 메모리를 언제 해제할지에 대해 수동으로 결정하는 것이 편리할 때가 있다. 수동으로 메모리를 해제하려면, 객체 메모리에 도달할 수 없도록 명시하는 기능이 있어야 한다.

하지만 현재의 javascript에서는 명시적으로 또는 프로그래밍 방식으로 가비지 컬렉션을 작동할 수 없다.

[참고사이트]

MDN 가비지 컬렉션 : [https://developer.mozilla.org/ko/docs/Web/JavaScript/Memory_Management](https://developer.mozilla.org/ko/docs/Web/JavaScript/Memory_Management)

JAVASCRIPT.INFO: [https://ko.javascript.info/garbage-collection](https://ko.javascript.info/garbage-collection)
